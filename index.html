<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Raycaster</title>
  <style type="text/css">
    body {
      margin: 0;
      background: #282c34;
      overflow: hidden;
    }

    #mainCanvas {
      padding-left: 0;
      padding-right: 0;
      margin-left: auto;
      margin-right: auto;
      display: block;
    }

    #miniCanvas {
      position: absolute;
      top: 0;
      left: 0;
    }
  </style>
</head>

<body>
  <!-- <button class="toggle">toggle</button> -->
  <canvas id="mainCanvas"></canvas>
  <canvas id="miniCanvas"></canvas>
  <script src='Player.js'></script>
  <script src='map.js'></script>
  <script src='Controls.js'></script>
  <script src='sizeCanvas.js'></script>
  <script src='Ray.js'></script>

  <script>
    // init variables
    const CIRCLE = Math.PI * 2
    const gridSize = Math.sqrt(map.length)
    const mainCtx = document.getElementById("mainCanvas").getContext("2d")
    const miniCtx = document.getElementById("miniCanvas").getContext("2d")
    let lastTime
    let dt
    let width
    let height
    let mcWidth // mini canvas width / height
    let mcHeight // mcdonald's height
    let pause = false
    let now = Date.now()
    let maxMap = false
    let blockWidth
    let blockHeight
    let fov = 90
    let viewDistance = 90
    let player
    let controls
    let rays = []

    window.addEventListener('click', () => {
      maxMap = !maxMap
      sizeCanvas()
    })

    function distance(x1, y1, x2, y2) {
      let a = x1 - x2;
      let b = y1 - y2;
      return Math.hypot(a, b)
    }

    function drawMap(ctx) {
      map.forEach((type, i) => {
        ctx.beginPath()
        let startX = (i % gridSize) * blockSize
        let startY = Math.floor(i / gridSize) * blockSize
        ctx.rect(startX, startY, blockSize, blockSize)
        ctx.closePath()
        ctx.strokeStyle = 'white'
        ctx.stroke()
        ctx.fillStyle = type === 1 ? '#beeeef' : 'black'
        ctx.fill()
      })
    }

    function drawPlayer(ctx) {
      ctx.save() // saves the original rotation
      ctx.translate(player.x, player.y) // move pointer to player position
      ctx.rotate(player.direction) // rotate canvas
      ctx.translate(-player.x, -player.y) // move pointer back to origin

      // draw a triangle
      ctx.beginPath()
      ctx.moveTo(player.x, player.y);
      ctx.lineTo(player.x - 50, player.y + 20);
      ctx.lineTo(player.x - 50, player.y - 20);
      ctx.closePath()
      ctx.fillStyle = '#00cc00'
      ctx.fill()

      ctx.restore() // sets rotation back to where it was when we called save()
    }

    function castRays() {
      rays = []
      for (let i = (-fov / 2); i < (fov / 2); i++) {
        let rayDirection = (((player.direction + (i * Math.PI / 180)) + CIRCLE) % CIRCLE)
        let ray = new Ray(rayDirection)
        rays.push(ray)
        ray.collide()
      }
    }

    function drawRay(ray, ctx) {
      let [endX, endY] = ray.collide()
      if (endX === -1) return
      ctx.beginPath()
      ctx.moveTo(player.x, player.y)
      ctx.lineTo(endX, endY)
      ctx.closePath()
      ctx.strokeStyle = 'red'
      ctx.stroke()
    }

    function drawColumns(ctx) {
      let canvas = mainCanvas
      let columnWidth = mainCanvas.width / fov
      rays.forEach((ray, i) => {
        let distance = ray.length
        ctx.beginPath();
        let x = i * columnWidth
        // difference between ray angle and player angle
        let angleDif = player.direction - ray.direction
        if (angleDif < 0) angleDif += CIRCLE
        if (angleDif > CIRCLE) angleDif -= CIRCLE
        let columnHeight = blockSize * height / (Math.cos(angleDif) * distance)
        let y = (canvas.height / 2) - columnHeight / 2
        ctx.rect(x, y, columnWidth, columnHeight)
        ctx.fillStyle = "blue"
        ctx.closePath()
        ctx.fill()
      })
    }

    function render2D(ctx, canvas) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "white"
      ctx.fillRect(0, 0, canvas.width, canvas.height)
      drawMap(ctx)
      drawPlayer(ctx)
      rays.forEach(ray => drawRay(ray, ctx))
    }

    function render3D(ctx, canvas) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "white"
      ctx.fillRect(0, 0, canvas.width, canvas.height)
      drawColumns(ctx)
    }

    // function drawUI() {
    //   let buttonWidth = miniCanvas.width / 4
    //   miniCtx.fillStyle = 'grey'
    //   miniCtx.fillRect(miniCanvas.width - buttonWidth, 0, buttonWidth, buttonWidth / 2)
    //   miniCtx.font = "10px Arial";
    //   miniCtx.fillStyle = 'white'
    //   miniCtx.fillText("Toggle", miniCanvas.width - buttonWidth + 5, buttonWidth / 4 + 5);

    // }

    // Main animation loop
    function animationLoop() {
      if (!lastTime) lastTime = Date.now()
      now = Date.now()
      dt = now - lastTime
      player.update(dt)
      // only calculate rays if we've moved
      if (!(player.x === player.lastX && player.lastY === player.y && player.lastDirection === player.direction)) castRays()
      render3D(mainCtx, mainCanvas)
      render2D(miniCtx, miniCanvas)
      // drawUI()
      lastTime = now
      window.requestAnimationFrame(animationLoop);
    }

    window.onload = () => {
      window.addEventListener("resize", sizeCanvas, false);
      sizeCanvas();
      player = new Player(blockSize * gridSize - blockSize - blockSize / 2, blockSize * gridSize - blockSize - blockSize / 2, 5 * Math.PI / 4)
      controls = new Controls()
      // Schedule the main animation loop
      window.requestAnimationFrame(animationLoop);
    };
  </script>
</body>

</html>